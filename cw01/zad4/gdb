Program zmodyfikowano dodając instrukcję:
strcpy(NULL,"text");
Instrukcja wpisuje tablicę char pod adres NULL. Kompilator nie wyrzuca błędu. Powstaje błąd krytyczny i zrzut pamięci w chwili uruchomienia programu - Segmentation fault. Generuje się plik core. Aby znaleźć błąd można skorzystać z narzędia gdb. Uruchamiamy program instrukcją 
gdb ./nazwa_programu
W ten sposób wchodzimy w trym debuggowania. Możemy teraz testować w której linijce program przestaje działać poprawnie. Do tego celu używamy instrukcji:
b nr_linii
Instrukcją 
c <continue>
możemy przechodzić do następnego breakpointa (punktu przerwania). W ten sposób możemy ustalić miejsce błędnej instrukcji.


//po uruchomieniu programu
...
START: real: 0.0047630000, user: 0.0000000000, sys: 0.0000000000
START: real: 0.0047660000, user: 0.0000000000, sys: 0.0000000000
START: real: 0.0047690000, user: 0.0000000000, sys: 0.0000000000
START: real: 0.0047710000, user: 0.0000000000, sys: 0.0000000000
START: real: 0.0047740000, user: 0.0000000000, sys: 0.0000000000
START: real: 0.0047780000, user: 0.0000000000, sys: 0.0000000000

Time of making adress book on List:
START: real: 0.0047820000, user: 0.0000000000, sys: 0.0000000000
Delete operation: real: 0.0000030000, user: 0.0000000000, sys: 0.0000000000
Find operation: real: 0.0000010000, user: 0.0000000000, sys: 0.0000000000
Sort operation: real: 0.0027820000, user: 0.0000000000, sys: 0.0000000000

For tree structure: 
Segmentation fault (zrzut pamięci)

//po uruchomieniu w debugerze gdb

Core was generated by `./timeTestStatic0'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  main () at timeTest.c:84
84		strcpy(NULL,"text");
(gdb) 
debugger podał informację, w której linijce wystąpił błąd 

//informacje o zmiennych
(gdb) info locals
start = {tms_utime = 1, tms_stime = 0, tms_cutime = 0, tms_cstime = 0}
real_start = 24769
t = {tms_utime = 1, tms_stime = 0, tms_cutime = 0, tms_cstime = 0}
c = 24740
l = 0x169a010
tree = 0x16a9e60
per = 0x0



